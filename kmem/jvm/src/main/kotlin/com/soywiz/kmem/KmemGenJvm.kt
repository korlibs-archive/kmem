// @WARNING: File AUTOGENERATED by `kmem/jvm/src/test/kotlin/Generator.kt` do not modify manually!
// @TODO: USELESS_CAST is required since it requires a cast to work, but IDE says that that cast is not necessary
@file:Suppress("NOTHING_TO_INLINE", "EXTENSION_SHADOWED_BY_MEMBER", "RedundantUnitReturnType", "FunctionName", "USELESS_CAST")
package com.soywiz.kmem

import java.nio.*
import java.util.*

fun ByteBuffer.slice(offset: Int, size: Int): ByteBuffer = run { val out = this.slice(); out.position(this.position() + offset); out.limit(size); return out }
fun ShortBuffer.slice(offset: Int, size: Int): ShortBuffer = run { val out = this.slice(); out.position(this.position() + offset); out.limit(size); return out }
fun IntBuffer.slice(offset: Int, size: Int): IntBuffer = run { val out = this.slice(); out.position(this.position() + offset); out.limit(size); return out }
fun FloatBuffer.slice(offset: Int, size: Int): FloatBuffer = run { val out = this.slice(); out.position(this.position() + offset); out.limit(size); return out }
fun DoubleBuffer.slice(offset: Int, size: Int): DoubleBuffer = run { val out = this.slice(); out.position(this.position() + offset); out.limit(size); return out }
actual class MemBuffer(val buffer: ByteBuffer, val size: Int)
actual fun MemBufferAlloc(size: Int): MemBuffer = MemBuffer(ByteBuffer.allocateDirect((size + 0xF) and 0xF.inv()).order(ByteOrder.nativeOrder()), size)
actual fun MemBufferWrap(array: ByteArray): MemBuffer = MemBuffer(ByteBuffer.wrap(array).order(ByteOrder.nativeOrder()), array.size)
actual inline val MemBuffer.size: Int get() = this.size

actual fun MemBuffer._sliceInt8Buffer(offset: Int, size: Int): Int8Buffer = Int8Buffer(this, this.buffer.slice(offset, size))
actual fun MemBuffer._sliceInt16Buffer(offset: Int, size: Int): Int16Buffer = Int16Buffer(this, this.buffer.asShortBuffer().slice(offset, size))
actual fun MemBuffer._sliceInt32Buffer(offset: Int, size: Int): Int32Buffer = Int32Buffer(this, this.buffer.asIntBuffer().slice(offset, size))
actual fun MemBuffer._sliceFloat32Buffer(offset: Int, size: Int): Float32Buffer = Float32Buffer(this, this.buffer.asFloatBuffer().slice(offset, size))
actual fun MemBuffer._sliceFloat64Buffer(offset: Int, size: Int): Float64Buffer = Float64Buffer(this, this.buffer.asDoubleBuffer().slice(offset, size))

actual class Int8Buffer(val mbuffer: MemBuffer, val jbuffer: ByteBuffer)
actual val Int8Buffer.buffer: MemBuffer get() = mbuffer
actual val Int8Buffer.offset: Int get() = jbuffer.position()
actual val Int8Buffer.size: Int get() = jbuffer.limit()
actual operator fun Int8Buffer.get(index: Int): Byte = jbuffer.get(index)
actual operator fun Int8Buffer.set(index: Int, value: Byte): Unit = run { jbuffer.put(index, value) }

actual class Int16Buffer(val mbuffer: MemBuffer, val jbuffer: ShortBuffer)
actual val Int16Buffer.buffer: MemBuffer get() = mbuffer
actual val Int16Buffer.offset: Int get() = jbuffer.position()
actual val Int16Buffer.size: Int get() = jbuffer.limit()
actual operator fun Int16Buffer.get(index: Int): Short = jbuffer.get(index)
actual operator fun Int16Buffer.set(index: Int, value: Short): Unit = run { jbuffer.put(index, value) }

actual class Int32Buffer(val mbuffer: MemBuffer, val jbuffer: IntBuffer)
actual val Int32Buffer.buffer: MemBuffer get() = mbuffer
actual val Int32Buffer.offset: Int get() = jbuffer.position()
actual val Int32Buffer.size: Int get() = jbuffer.limit()
actual operator fun Int32Buffer.get(index: Int): Int = jbuffer.get(index)
actual operator fun Int32Buffer.set(index: Int, value: Int): Unit = run { jbuffer.put(index, value) }

actual class Float32Buffer(val mbuffer: MemBuffer, val jbuffer: FloatBuffer)
actual val Float32Buffer.buffer: MemBuffer get() = mbuffer
actual val Float32Buffer.offset: Int get() = jbuffer.position()
actual val Float32Buffer.size: Int get() = jbuffer.limit()
actual operator fun Float32Buffer.get(index: Int): Float = jbuffer.get(index)
actual operator fun Float32Buffer.set(index: Int, value: Float): Unit = run { jbuffer.put(index, value) }

actual class Float64Buffer(val mbuffer: MemBuffer, val jbuffer: DoubleBuffer)
actual val Float64Buffer.buffer: MemBuffer get() = mbuffer
actual val Float64Buffer.offset: Int get() = jbuffer.position()
actual val Float64Buffer.size: Int get() = jbuffer.limit()
actual operator fun Float64Buffer.get(index: Int): Double = jbuffer.get(index)
actual operator fun Float64Buffer.set(index: Int, value: Double): Unit = run { jbuffer.put(index, value) }

actual fun arraycopy(src: ByteArray, srcPos: Int, dst: ByteArray, dstPos: Int, size: Int): Unit = System.arraycopy(src, srcPos, dst, dstPos, size)
actual fun arraycopy(src: ShortArray, srcPos: Int, dst: ShortArray, dstPos: Int, size: Int): Unit = System.arraycopy(src, srcPos, dst, dstPos, size)
actual fun arraycopy(src: IntArray, srcPos: Int, dst: IntArray, dstPos: Int, size: Int): Unit = System.arraycopy(src, srcPos, dst, dstPos, size)
actual fun arraycopy(src: FloatArray, srcPos: Int, dst: FloatArray, dstPos: Int, size: Int): Unit = System.arraycopy(src, srcPos, dst, dstPos, size)
actual fun arraycopy(src: DoubleArray, srcPos: Int, dst: DoubleArray, dstPos: Int, size: Int): Unit = System.arraycopy(src, srcPos, dst, dstPos, size)

actual fun arraycopy(src: MemBuffer, srcPos: Int, dst: MemBuffer, dstPos: Int, size: Int): Unit = run { dst.buffer.slice(dstPos, size).put(src.buffer.slice(srcPos, size)) }
actual fun arraycopy(src: ByteArray, srcPos: Int, dst: MemBuffer, dstPos: Int, size: Int): Unit = run { (dst.sliceInt8Buffer(dstPos, size) as Int8Buffer).jbuffer.put(src, srcPos, size) }
actual fun arraycopy(src: MemBuffer, srcPos: Int, dst: ByteArray, dstPos: Int, size: Int): Unit = TODO()
actual fun arraycopy(src: ShortArray, srcPos: Int, dst: MemBuffer, dstPos: Int, size: Int): Unit = run { (dst.sliceInt16Buffer(dstPos, size) as Int16Buffer).jbuffer.put(src, srcPos, size) }
actual fun arraycopy(src: MemBuffer, srcPos: Int, dst: ShortArray, dstPos: Int, size: Int): Unit = TODO()
actual fun arraycopy(src: IntArray, srcPos: Int, dst: MemBuffer, dstPos: Int, size: Int): Unit = run { (dst.sliceInt32Buffer(dstPos, size) as Int32Buffer).jbuffer.put(src, srcPos, size) }
actual fun arraycopy(src: MemBuffer, srcPos: Int, dst: IntArray, dstPos: Int, size: Int): Unit = TODO()
actual fun arraycopy(src: FloatArray, srcPos: Int, dst: MemBuffer, dstPos: Int, size: Int): Unit = run { (dst.sliceFloat32Buffer(dstPos, size) as Float32Buffer).jbuffer.put(src, srcPos, size) }
actual fun arraycopy(src: MemBuffer, srcPos: Int, dst: FloatArray, dstPos: Int, size: Int): Unit = TODO()
actual fun arraycopy(src: DoubleArray, srcPos: Int, dst: MemBuffer, dstPos: Int, size: Int): Unit = run { (dst.sliceFloat64Buffer(dstPos, size) as Float64Buffer).jbuffer.put(src, srcPos, size) }
actual fun arraycopy(src: MemBuffer, srcPos: Int, dst: DoubleArray, dstPos: Int, size: Int): Unit = TODO()

@PublishedApi actual internal fun _fill(array: ByteArray, value: Byte, pos: Int, size: Int): Unit = Arrays.fill(array, pos, pos + size, value)
@PublishedApi actual internal fun _fill(array: ShortArray, value: Short, pos: Int, size: Int): Unit = Arrays.fill(array, pos, pos + size, value)
@PublishedApi actual internal fun _fill(array: IntArray, value: Int, pos: Int, size: Int): Unit = Arrays.fill(array, pos, pos + size, value)
@PublishedApi actual internal fun _fill(array: FloatArray, value: Float, pos: Int, size: Int): Unit = Arrays.fill(array, pos, pos + size, value)
@PublishedApi actual internal fun _fill(array: DoubleArray, value: Double, pos: Int, size: Int): Unit = Arrays.fill(array, pos, pos + size, value)
