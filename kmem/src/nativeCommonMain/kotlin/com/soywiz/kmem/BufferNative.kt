// @WARNING: File AUTOGENERATED by `korlibs-generator-jvm/src/com/soywiz/korlibs` @ korlibs/kmem do not modify manually!
// @TODO: USELESS_CAST is required since it requires a cast to work, but IDE says that that cast is not necessary
@file:Suppress("NOTHING_TO_INLINE", "EXTENSION_SHADOWED_BY_MEMBER", "RedundantUnitReturnType", "FunctionName", "USELESS_CAST")
package com.soywiz.kmem

import kotlinx.cinterop.*
import platform.posix.*
import com.soywiz.kmem.internal.*

actual class MemBuffer(val data: ByteArray)
actual fun MemBufferAlloc(size: Int): MemBuffer = MemBuffer(ByteArray(size))
actual fun MemBufferAllocNoDirect(size: Int): MemBuffer = MemBuffer(ByteArray(size))
actual fun MemBufferWrap(array: ByteArray): MemBuffer = MemBuffer(array)
actual inline val MemBuffer.size: Int get() = data.size

actual fun MemBuffer._sliceInt8Buffer(offset: Int, size: Int): Int8Buffer = Int8Buffer(this, offset * 1, size)
actual fun MemBuffer._sliceInt16Buffer(offset: Int, size: Int): Int16Buffer = Int16Buffer(this, offset * 2, size)
actual fun MemBuffer._sliceInt32Buffer(offset: Int, size: Int): Int32Buffer = Int32Buffer(this, offset * 4, size)
actual fun MemBuffer._sliceFloat32Buffer(offset: Int, size: Int): Float32Buffer = Float32Buffer(this, offset * 4, size)
actual fun MemBuffer._sliceFloat64Buffer(offset: Int, size: Int): Float64Buffer = Float64Buffer(this, offset * 8, size)

// @TODO: https://youtrack.jetbrains.com/issue/KT-46427
//@SymbolName("Kotlin_ByteArray_setFloatAtUnsafe") public external fun ByteArray.setFloatAtUnsafe(index: Int, value: Float)
//@SymbolName("Kotlin_ByteArray_getFloatAtUnsafe") public external fun ByteArray.getFloatAtUnsafe(index: Int): Float

private inline fun ByteArray.setFloatAtUnsafe(index: Int, value: Float) = setFloatAt(index, value)
private inline fun ByteArray.getFloatAtUnsafe(index: Int): Float = getFloatAt(index)

actual typealias DataBuffer = MemBuffer
actual val DataBuffer.mem: MemBuffer get() = this
actual fun MemBuffer.getData(): DataBuffer = this
actual fun DataBuffer.getByte(index: Int): Byte = data.get(index)
actual fun DataBuffer.getShort(index: Int): Short = data.getShortAt(index)
actual fun DataBuffer.getInt(index: Int): Int = data.getIntAt(index)
actual fun DataBuffer.getFloat(index: Int): Float = data.getFloatAtUnsafe(index)
actual fun DataBuffer.getDouble(index: Int): Double = data.getDoubleAt(index)
actual fun DataBuffer.setByte(index: Int, value: Byte): Unit = data.set(index, value)
actual fun DataBuffer.setShort(index: Int, value: Short): Unit = data.setShortAt(index, value)
actual fun DataBuffer.setInt(index: Int, value: Int): Unit = data.setIntAt(index, value)
actual fun DataBuffer.setFloat(index: Int, value: Float): Unit = data.setFloatAtUnsafe(index, value)
actual fun DataBuffer.setDouble(index: Int, value: Double): Unit = data.setDoubleAt(index, value)

@PublishedApi
internal const val BYTE_SIZE = 1

actual class Int8Buffer(val mbuffer: MemBuffer, val byteOffset: Int, val size: Int) {
    val MEM_OFFSET = byteOffset / BYTE_SIZE
    val MEM_SIZE = size / BYTE_SIZE
    inline fun getByteIndex(index: Int) = byteOffset + index * BYTE_SIZE
}
actual inline val Int8Buffer.mem: MemBuffer get() = mbuffer
actual inline val Int8Buffer.offset: Int get() = MEM_OFFSET
actual inline val Int8Buffer.size: Int get() = MEM_SIZE
actual operator fun Int8Buffer.get(index: Int): Byte = mbuffer.getByte(getByteIndex(index))
actual operator fun Int8Buffer.set(index: Int, value: Byte): Unit = mbuffer.setByte(getByteIndex(index), value)

@PublishedApi
internal const val SHORT_SIZE = 2

actual class Int16Buffer(val mbuffer: MemBuffer, val byteOffset: Int, val size: Int) {
    val MEM_OFFSET = byteOffset / SHORT_SIZE
    val MEM_SIZE = size / SHORT_SIZE
    inline fun getByteIndex(index: Int) = byteOffset + index * SHORT_SIZE
}
actual inline val Int16Buffer.mem: MemBuffer get() = mbuffer
actual inline val Int16Buffer.offset: Int get() = MEM_OFFSET
actual inline val Int16Buffer.size: Int get() = MEM_SIZE
actual operator fun Int16Buffer.get(index: Int): Short = mbuffer.getShort(getByteIndex(index))
actual operator fun Int16Buffer.set(index: Int, value: Short): Unit = mbuffer.setShort(getByteIndex(index), value)

@PublishedApi
internal const val INT_SIZE = 4

actual class Int32Buffer(val mbuffer: MemBuffer, val byteOffset: Int, val size: Int) {
    val MEM_OFFSET = byteOffset / INT_SIZE
    val MEM_SIZE = size / INT_SIZE
    inline fun getByteIndex(index: Int) = byteOffset + index * INT_SIZE
}
actual inline val Int32Buffer.mem: MemBuffer get() = mbuffer
actual inline val Int32Buffer.offset: Int get() = MEM_OFFSET
actual inline val Int32Buffer.size: Int get() = MEM_SIZE
actual operator fun Int32Buffer.get(index: Int): Int = mbuffer.getInt(getByteIndex(index))
actual operator fun Int32Buffer.set(index: Int, value: Int): Unit = mbuffer.setInt(getByteIndex(index), value)

@PublishedApi
internal const val FLOAT_SIZE = 4

actual class Float32Buffer(val mbuffer: MemBuffer, val byteOffset: Int, val size: Int) {
    val MEM_OFFSET = byteOffset / FLOAT_SIZE
    val MEM_SIZE = size / FLOAT_SIZE
    inline fun getByteIndex(index: Int) = byteOffset + index * FLOAT_SIZE
}
actual inline val Float32Buffer.mem: MemBuffer get() = mbuffer
actual inline val Float32Buffer.offset: Int get() = MEM_OFFSET
actual inline val Float32Buffer.size: Int get() = MEM_SIZE
actual operator fun Float32Buffer.get(index: Int): Float = mbuffer.getFloat(getByteIndex(index))
actual operator fun Float32Buffer.set(index: Int, value: Float): Unit = mbuffer.setFloat(getByteIndex(index), value)

@PublishedApi
internal const val DOUBLE_SIZE = 8

actual class Float64Buffer(val mbuffer: MemBuffer, val byteOffset: Int, val size: Int) {
    val MEM_OFFSET = byteOffset / DOUBLE_SIZE
    val MEM_SIZE = size / DOUBLE_SIZE
    inline fun getByteIndex(index: Int) = byteOffset + index * DOUBLE_SIZE
}
actual inline val Float64Buffer.mem: MemBuffer get() = mbuffer
actual inline val Float64Buffer.offset: Int get() = MEM_OFFSET
actual inline val Float64Buffer.size: Int get() = MEM_SIZE
actual operator fun Float64Buffer.get(index: Int): Double = mbuffer.getDouble(getByteIndex(index))
actual operator fun Float64Buffer.set(index: Int, value: Double): Unit = mbuffer.setDouble(getByteIndex(index), value)

@PublishedApi internal const val SHORT_SIZE_BYTES = 2
@PublishedApi internal const val INT_SIZE_BYTES = 4
@PublishedApi internal const val FLOAT_SIZE_BYTES = 4
@PublishedApi internal const val DOUBLE_SIZE_BYTES = 8

actual fun arraycopy(src: MemBuffer, srcPos: Int, dst: MemBuffer, dstPos: Int, size: Int): Unit {
    src.data.copyInto(dst.data, dstPos, srcPos, srcPos + size)
}
actual fun arraycopy(src: ByteArray, srcPos: Int, dst: MemBuffer, dstPos: Int, size: Int): Unit {
    src.copyInto(dst.data, dstPos, srcPos, srcPos + size)
}
actual fun arraycopy(src: MemBuffer, srcPos: Int, dst: ByteArray, dstPos: Int, size: Int): Unit {
    src.data.copyInto(dst, dstPos, srcPos, srcPos + size)
}
actual fun arraycopy(src: ShortArray, srcPos: Int, dst: MemBuffer, dstPos: Int, size: Int): Unit {
    for (n in 0 until size) dst.data.setShortAt((dstPos + n) * SHORT_SIZE_BYTES, src[srcPos + n])
}
actual fun arraycopy(src: IntArray, srcPos: Int, dst: MemBuffer, dstPos: Int, size: Int): Unit {
    for (n in 0 until size) dst.data.setIntAt((dstPos + n) * INT_SIZE_BYTES, src[srcPos + n])
}
actual fun arraycopy(src: FloatArray, srcPos: Int, dst: MemBuffer, dstPos: Int, size: Int): Unit {
    for (n in 0 until size) dst.data.setFloatAt((dstPos + n) * FLOAT_SIZE_BYTES, src[srcPos + n])
}
actual fun arraycopy(src: DoubleArray, srcPos: Int, dst: MemBuffer, dstPos: Int, size: Int): Unit {
    for (n in 0 until size) dst.data.setDoubleAt((dstPos + n) * DOUBLE_SIZE_BYTES, src[srcPos + n])
}
actual fun arraycopy(src: MemBuffer, srcPos: Int, dst: ShortArray, dstPos: Int, size: Int): Unit {
    for (n in 0 until size) dst[dstPos + n] = src.data.getShortAt((srcPos + n) * SHORT_SIZE_BYTES)
}
actual fun arraycopy(src: MemBuffer, srcPos: Int, dst: IntArray, dstPos: Int, size: Int): Unit {
    for (n in 0 until size) dst[dstPos + n] = src.data.getIntAt((srcPos + n) * INT_SIZE_BYTES)
}
actual fun arraycopy(src: MemBuffer, srcPos: Int, dst: FloatArray, dstPos: Int, size: Int): Unit {
    for (n in 0 until size) dst[dstPos + n] = src.data.getFloatAt((srcPos + n) * FLOAT_SIZE_BYTES)
}
actual fun arraycopy(src: MemBuffer, srcPos: Int, dst: DoubleArray, dstPos: Int, size: Int): Unit {
    for (n in 0 until size) dst[dstPos + n] = src.data.getDoubleAt((srcPos + n) * DOUBLE_SIZE_BYTES)
}

actual abstract class Fast32Buffer(val bb: ByteArray)
//actual /*inline*/ class Fast32Buffer(val bb: ByteArray)
class Fast32BufferF(bb: ByteArray) : Fast32Buffer(bb)

actual fun NewFast32Buffer(mem: MemBuffer): Fast32Buffer = Fast32BufferF(mem.data)

actual val Fast32Buffer.length: Int get() = this.bb.size * 4
actual inline fun Fast32Buffer.getF(index: Int): Float = this.bb.getFloatAt(index * 4)
actual inline fun Fast32Buffer.setF(index: Int, value: Float) { this.bb.setFloatAt(index * 4, value) }
actual inline fun Fast32Buffer.getI(index: Int): Int = this.bb.getIntAt(index * 4)
actual inline fun Fast32Buffer.setI(index: Int, value: Int) { this.bb.setIntAt(index * 4, value) }
